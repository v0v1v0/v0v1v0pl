<div class="container">

<table style="width: 100%;"><tr>
<td>exceeds_tumbling_sum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Check When the Tumbling Sum of a Vector Exceeds a Threshold</h2>

<h3>Description</h3>

<p>The tumbling sum is calculated as the partial cumulative sum of a vector
until a threshold is exceeded. Once this happens, the tumbling sum is
calculated from zero again. <code>exceeds_tumbling_sum()</code> returns <code>TRUE</code> whenever
this threshold is hit/exceeded and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class="language-R">exceeds_tumbling_sum(x, threshold, inclusive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>numeric</code> vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>a <code>numeric</code> scalar</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inclusive</code></td>
<td>
<p>a <code>logical</code> scalar. If <code>TRUE</code> inclusive bounds are used
(i.e. the threshold is checked with <code>&gt;=</code>), otherwise exclusive</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is for example useful if you have high frequency GPS positions
and want to keep only points that are at least <code>x</code> seconds apart.
</p>


<h3>Value</h3>

<p>a <code>logical</code> vector of the same length as <code>x</code> that is <code>TRUE</code> whenever
<code>threshold</code> was exceeded and <code>FALSE</code> otherwise
</p>


<h3>See Also</h3>

<p><code>MESS::cumsumbinning()</code> does something very similar, but returns
group indices instead of a logical vector.
</p>


<h3>Examples</h3>

<pre><code class="language-R">exceeds_tumbling_sum(c(1, 3, 3, 3), 4)
</code></pre>


</div>