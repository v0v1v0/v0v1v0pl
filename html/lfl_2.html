<div class="container">

<table style="width: 100%;"><tr>
<td>algebra</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Algebra for Fuzzy Sets</h2>

<h3>Description</h3>

<p>Compute triangular norms (t-norms), triangular conorms (t-conorms), residua,
bi-residua, and negations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">algebra(name, stdneg = FALSE, ...)

is.algebra(a)

goedel.tnorm(...)

lukas.tnorm(...)

goguen.tnorm(...)

pgoedel.tnorm(...)

plukas.tnorm(...)

pgoguen.tnorm(...)

goedel.tconorm(...)

lukas.tconorm(...)

goguen.tconorm(...)

pgoedel.tconorm(...)

plukas.tconorm(...)

pgoguen.tconorm(...)

goedel.residuum(x, y)

lukas.residuum(x, y)

goguen.residuum(x, y)

goedel.biresiduum(x, y)

lukas.biresiduum(x, y)

goguen.biresiduum(x, y)

invol.neg(x)

strict.neg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>The name of the algebra to be created. Must be one of: "goedel",
"lukasiewicz", "goguen" (or an unambiguous abbreviation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stdneg</code></td>
<td>
<p>(Deprecated.) <code>TRUE</code> if to force the use of a "standard" negation (i.e.
involutive negation).  Otherwise, the appropriate negation is used in the
algebra (e.g. strict negation in Goedel and Goguen algebra and involutive
negation in Lukasiewicz algebra).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For t-norms and t-conorms, these arguments are numeric vectors
of values to compute t-norms or t-conorms from.  Values outside the
<code class="reqn">[0,1]</code> interval cause an error. NA values are also permitted.
</p>
<p>For the <code>algebra()</code> function, these arguments are passed to the factory
functions that create the algebra. (Currently unused.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>An object to be checked if it is a valid algebra (i.e. a list
returned by the <code>algebra</code> function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector of values to compute a residuum or bi-residuum from.
Values outside the <code class="reqn">[0,1]</code> interval cause an error. NA values are also
permitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Numeric vector of values to compute a residuum or bi-residuum from.
Values outside the <code class="reqn">[0,1]</code> interval cause an error. NA values are also
permitted.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>goedel.tnorm</code>, <code>lukas.tnorm</code>, and <code>goguen.tnorm</code> compute the
Goedel, Lukasiewicz, and Goguen triangular norm (t-norm) from all values in
the arguments. If the arguments are vectors they are combined together
firstly so that a numeric vector of length 1 is returned.
</p>
<p><code>pgoedel.tnorm</code>, <code>plukas.tnorm</code>, and <code>pgoguen.tnorm</code> compute
the same t-norms, but in an element-wise manner. I.e. the values
with indices 1 of all arguments are used to compute the t-norm, then the
second values (while recycling the vectors if they do not have the same
size) so that the result is a vector of values.
</p>
<p><code>goedel.tconorm</code>, <code>lukas.tconorm</code>, <code>goguen.tconorm</code>, are
similar to the previously mentioned functions, except that they compute
triangular conorms (t-conorms).  <code>pgoedel.tconorm</code>,
<code>plukas.tconorm</code>, and <code>pgoguen.tconorm</code> are their element-wise alternatives.
</p>
<p><code>goedel.residuum</code>, <code>lukas.residuum</code>, and <code>goguen.residuum</code>
compute residua (i.e. implications) and <code>goedel.biresiduum</code>,
<code>lukas.biresiduum</code>, and <code>goguen.biresiduum</code> compute bi-residua. Residua and
bi-residua are computed in an element-wise manner, for each corresponding
pair of values in <code>x</code> and <code>y</code> arguments.
</p>
<p><code>invol.neg</code> and <code>strict.neg</code> compute the involutive and strict
negation, respectively.
</p>
<p>Let <code class="reqn">a</code>, <code class="reqn">b</code> be values from the interval <code class="reqn">[0, 1]</code>. The realized functions
can be defined as follows:
</p>

<ul>
<li>
<p> Goedel t-norm: <code class="reqn">min{a, b}</code>;
</p>
</li>
<li>
<p> Goguen t-norm: <code class="reqn">ab</code>;
</p>
</li>
<li>
<p> Lukasiewicz t-norm: <code class="reqn">max{0, a+b-1}</code>;
</p>
</li>
<li>
<p> Goedel t-conorm: <code class="reqn">max{a, b}</code>;
</p>
</li>
<li>
<p> Goguen t-conorm: <code class="reqn">a+b-ab</code>;
</p>
</li>
<li>
<p> Lukasiewicz t-conorm: <code class="reqn">min{1, a+b}</code>;
</p>
</li>
<li>
<p> Goedel residuum (standard Goedel implication): <code class="reqn">1</code> if <code class="reqn">a \le b</code> and
<code class="reqn">b</code> otherwise;
</p>
</li>
<li>
<p> Goguen residuum (implication): <code class="reqn">1</code> if <code class="reqn">a \le b</code> and <code class="reqn">b/a</code>
otherwise;
</p>
</li>
<li>
<p> Lukasiewicz residuum (standard Lukasiewicz implication): <code class="reqn">1</code> if
<code class="reqn">a \le b</code> and <code class="reqn">1-a+b</code> otherwise;
</p>
</li>
<li>
<p> Involutive negation: <code class="reqn">1-x</code>;
</p>
</li>
<li>
<p> Strict negation: <code class="reqn">1</code> if <code class="reqn">x=0</code> and <code class="reqn">0</code> otherwise.
</p>
</li>
</ul>
<p>Bi-residuum <code class="reqn">B</code> is derived from residuum <code class="reqn">R</code>
as follows: </p>
<p style="text-align: center;"><code class="reqn">B(a, b) = inf(R(a, b), R(b, a)),</code>
</p>

<p>where <code class="reqn">inf</code> is the operation of infimum, which for all three algebras
corresponds to the <code class="reqn">min</code> operation.
</p>
<p>The arguments have to be numbers from the interval <code class="reqn">[0, 1]</code>. Values
outside that range cause an error. NaN values are treated as NAs.
</p>
<p>If some argument is NA or NaN, the result is NA. For other handling of missing values,
see algebraNA.
</p>
<p>Selection of a t-norm may serve as a basis for definition of other operations.
From the t-norm, the operation of a residual implication may be defined, which
in turn allows the definition of a residual negation. If the residual negation
is not involutive, the involutive negation is often added as a new operation
and together with the t-norm can be used to define the t-conorm. Therefore,
the <code>algebra</code> function returns a named list of operations derived from the selected
Goedel, Goguen, or Lukasiewicz t-norm. Concretely:
</p>

<ul>
<li> <p><code>algebra("goedel")</code>: returns the strict negation as the residual negation,
the involutive negation, and also the Goedel t-norm, t-conorm, residuum, and bi-residuum;
</p>
</li>
<li> <p><code>algebra("goguen")</code>: returns the strict negation as the residual negation,
the involutive negation, and also the Goguen t-norm, t-conorm, residuum, and bi-residuum;
</p>
</li>
<li> <p><code>algebra("lukasiewicz")</code>: returns involutive negation as both residual and involutive
negation, and also the Lukasiewicz t-norm, t-conorm, residuum, and bi-residuum.
</p>
</li>
</ul>
<p>Moreover, <code>algebra</code> returns the supremum and infimum functions computed as maximum and minimum,
respectively.
</p>
<p><code>is.algebra</code> tests whether the given <code>a</code> argument is a valid
algebra, i.e. a list returned by the <code>algebra</code> function.
</p>


<h3>Value</h3>

<p>Functions for t-norms and t-conorms (such as <code>goedel.tnorm</code>)
return a numeric vector of size 1 that is the result of the appropriate
t-norm or t-conorm applied on all values of all arguments.
</p>
<p>Element-wise versions of t-norms and t-conorms (such as <code>pgoedel.tnorm</code>)
return a vector of results after applying the appropriate t-norm or t-conorm
on argument in an element-wise (i.e. by indices) way. The
resulting vector is of length of the longest argument (shorter arguments are
recycled).
</p>
<p>Residua and bi-residua functions return a numeric vector of length of the
longest argument (shorter argument is recycled).
</p>
<p><code>strict.neg</code> and <code>invol.neg</code> compute negations and return a
numeric vector of the same size as the argument <code>x</code>.
</p>
<p><code>algebra</code> returns a list of functions of the requested algebra:
<code>"n"</code> (residual negation), <code>"ni"</code> (involutive negation), <code>"t"</code> (t-norm),
<code>"pt"</code> (element-wise t-norm),
<code>"c"</code> (t-conorm), <code>"pc"</code> (element-wise t-conorm), <code>"r"</code> (residuum),
<code>"b"</code> (bi-residuum), <code>"s"</code> (supremum),
<code>"ps"</code> (element-wise supremum), <code>"i"</code> (infimum), and
<code>"pi"</code> (element-wise infimum).
</p>
<p>For Lukasiewicz algebra, the elements <code>"n"</code> and <code>"ni"</code> are the same, i.e.
the <code>invol.neg</code> function. For Goedel and Goguen algebra, <code>"n"</code> (the residual
negation) equals <code>strict.neg</code> and <code>"ni"</code> (the involutive negation) equals
<code>invol.neg</code>.
</p>
<p><code>"s"</code>, <code>"ps"</code>, <code>"i"</code>, <code>"pi"</code> are the same for each type of algebra:
<code>goedel.conorm</code>, <code>pgoedel.conorm</code>, <code>goedel.tnorm</code>, and <code>pgoedel.tnorm</code>.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>Examples</h3>

<pre><code class="language-R">    # direct and element-wise version of functions
    goedel.tnorm(c(0.3, 0.2, 0.5), c(0.8, 0.1, 0.5))  # 0.1
    pgoedel.tnorm(c(0.3, 0.2, 0.5), c(0.8, 0.1, 0.5)) # c(0.3, 0.1, 0.5)

    # algebras
    x &lt;- runif(10)
    y &lt;- runif(10)
    a &lt;- algebra('goedel')
    a$n(x)     # residual negation
    a$ni(x)    # involutive negation
    a$t(x, y)  # t-norm
    a$pt(x, y) # element-wise t-norm
    a$c(x, y)  # t-conorm
    a$pc(x, y) # element-wise t-conorm
    a$r(x, y)  # residuum
    a$b(x, y)  # bi-residuum
    a$s(x, y)  # supremum
    a$ps(x, y) # element-wise supremum
    a$i(x, y)  # infimum
    a$pi(x, y) # element-wise infimum

    is.algebra(a) # TRUE
</code></pre>


</div>