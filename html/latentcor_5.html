<div class="container">

<table style="width: 100%;"><tr>
<td>interpolation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parallel version of multilinear interpolation generator for function approximation</h2>

<h3>Description</h3>

<p>Parallel version of multilinear interpolation generator for function approximation
</p>
<p>The primary method is <code>ipol</code> which
dispatches to some other method.  All the generated
interpolants accept as an argument a matrix of column
vectors. The generated functions also accept an argument
<code>threads=getOption('ipol.threads')</code> to utilize more than
one CPU if a matrix of column vectors is evaluated.  The option
<code>ipol.threads</code> is initialized from the environment variable
<code>IPOL_THREADS</code> upon loading of the package. It defaults to <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">interpolation(evalfun, grid_list, cores = detectCores(), int = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>evalfun</code></td>
<td>
<p>The objective function to be approximated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_list</code></td>
<td>
<p>A list for grid points (each element of list is a vector represents ticklabels on a dimension). The number of list elements are the dimension of function inputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>The numbers of cores (threads) of your machine to conduct parallel computing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int</code></td>
<td>
<p>Logical indicator. <code>int = TRUE</code> interpolant value multiplied by 10^7 then convert to interger to save memory. Original interpolant if <code>int = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other inputs for objective functions to be passed through.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The interpolants are ordinary R-objects and can be saved with <code>save()</code> and loaded
later with <code>load()</code> or serialized/unserialized with other tools, just like any R-object.
However, they contain calls to functions in the package, and while the author will make efforts
to ensure that generated interpolants are compatible with future versions of <span class="pkg">ipol</span>,
I can issue no such absolute guarantee.
</p>


<h3>Value</h3>

<p><code>interpolation</code> returns
</p>

<ul>
<li>
<p>value: A list of of length p corresponding to each variable. Returns NA for continuous variable; proportion of zeros for binary/truncated variables; the cumulative proportions of zeros and ones (e.g. first value is proportion of zeros, second value is proportion of zeros and ones) for ternary variable.
</p>
</li>
<li>
<p>interpolant: An interpolant function generated by <code>chebpol::chebpol</code> for interplation.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>ipol, interpolant
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: grid_list = list(seq(-0.5, 0.5, by = 0.5), seq(-0.5, 0.5, by = 0.5))
objfun = function(x, y) {x^2 + sqrt(y)}
evalfun = function(X) {objfun(X[1], X[2])}
value = interpolation(evalfun = evalfun, grid_list = grid_list)$value
interpolant = interpolation(evalfun = evalfun, grid_list = grid_list)$interpolant
## End(Not run)
</code></pre>


</div>