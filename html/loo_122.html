<div class="container">

<table style="width: 100%;"><tr>
<td>relative_eff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convenience function for computing relative efficiencies</h2>

<h3>Description</h3>

<p><code>relative_eff()</code> computes the the MCMC effective sample size divided by
the total sample size.
</p>


<h3>Usage</h3>

<pre><code class="language-R">relative_eff(x, ...)

## Default S3 method:
relative_eff(x, chain_id, ...)

## S3 method for class 'matrix'
relative_eff(x, chain_id, ..., cores = getOption("mc.cores", 1))

## S3 method for class 'array'
relative_eff(x, ..., cores = getOption("mc.cores", 1))

## S3 method for class ''function''
relative_eff(
  x,
  chain_id,
  ...,
  cores = getOption("mc.cores", 1),
  data = NULL,
  draws = NULL
)

## S3 method for class 'importance_sampling'
relative_eff(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector, matrix, 3-D array, or function. See the <strong>Methods (by
class)</strong> section below for details on specifying <code>x</code>, but where
"log-likelihood" is mentioned replace it with one of the following
depending on the use case:
</p>

<ul>
<li>
<p> For use with the <code>loo()</code> function, the values in <code>x</code> (or generated by
<code>x</code>, if a function) should be <strong>likelihood</strong> values
(i.e., <code>exp(log_lik)</code>), not on the log scale.
</p>
</li>
<li>
<p> For generic use with <code>psis()</code>, the values in <code>x</code> should be the reciprocal
of the importance ratios (i.e., <code>exp(-log_ratios)</code>).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chain_id</code></td>
<td>
<p>A vector of length <code>NROW(x)</code> containing MCMC chain
indexes for each each row of <code>x</code> (if a matrix) or each value in
<code>x</code> (if a vector). No <code>chain_id</code> is needed if <code>x</code> is a 3-D
array. If there are <code>C</code> chains then valid chain indexes are values
in <code>1:C</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>The number of cores to use for parallelization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data, draws, ...</code></td>
<td>
<p>Same as for the <code>loo()</code> function method.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of relative effective sample sizes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>relative_eff(default)</code>: A vector of length <code class="reqn">S</code> (posterior sample size).
</p>
</li>
<li> <p><code>relative_eff(matrix)</code>: An <code class="reqn">S</code> by <code class="reqn">N</code> matrix, where <code class="reqn">S</code> is the size
of the posterior sample (with all chains merged) and <code class="reqn">N</code> is the number
of data points.
</p>
</li>
<li> <p><code>relative_eff(array)</code>: An <code class="reqn">I</code> by <code class="reqn">C</code> by <code class="reqn">N</code> array, where <code class="reqn">I</code>
is the number of MCMC iterations per chain, <code class="reqn">C</code> is the number of
chains, and <code class="reqn">N</code> is the number of data points.
</p>
</li>
<li> <p><code>relative_eff(`function`)</code>: A function <code>f()</code> that takes arguments <code>data_i</code> and <code>draws</code> and returns a
vector containing the log-likelihood for a single observation <code>i</code> evaluated
at each posterior draw. The function should be written such that, for each
observation <code>i</code> in <code>1:N</code>, evaluating
</p>
<div class="sourceCode"><pre>f(data_i = data[i,, drop=FALSE], draws = draws)
</pre></div>
<p>results in a vector of length <code>S</code> (size of posterior sample). The
log-likelihood function can also have additional arguments but <code>data_i</code> and
<code>draws</code> are required.
</p>
<p>If using the function method then the arguments <code>data</code> and <code>draws</code> must also
be specified in the call to <code>loo()</code>:
</p>

<ul>
<li> <p><code>data</code>: A data frame or matrix containing the data (e.g.
observed outcome and predictors) needed to compute the pointwise
log-likelihood. For each observation <code>i</code>, the <code>i</code>th row of
<code>data</code> will be passed to the <code>data_i</code> argument of the
log-likelihood function.
</p>
</li>
<li> <p><code>draws</code>: An object containing the posterior draws for any
parameters needed to compute the pointwise log-likelihood. Unlike
<code>data</code>, which is indexed by observation, for each observation the
entire object <code>draws</code> will be passed to the <code>draws</code> argument of
the log-likelihood function.
</p>
</li>
<li>
<p> The <code>...</code> can be used if your log-likelihood function takes additional
arguments. These arguments are used like the <code>draws</code> argument in that they
are recycled for each observation.
</p>
</li>
</ul>
</li>
<li> <p><code>relative_eff(importance_sampling)</code>: If <code>x</code> is an object of class <code>"psis"</code>, <code>relative_eff()</code> simply returns
the <code>r_eff</code> attribute of <code>x</code>.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">LLarr &lt;- example_loglik_array()
LLmat &lt;- example_loglik_matrix()
dim(LLarr)
dim(LLmat)

rel_n_eff_1 &lt;- relative_eff(exp(LLarr))
rel_n_eff_2 &lt;- relative_eff(exp(LLmat), chain_id = rep(1:2, each = 500))
all.equal(rel_n_eff_1, rel_n_eff_2)

</code></pre>


</div>