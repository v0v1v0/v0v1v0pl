<div class="container">

<table style="width: 100%;"><tr>
<td>bounding_box</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create voxel array</h2>

<h3>Description</h3>

<p><code>bounding_box()</code> takes a table of voxel data and converts it into a
3-dimensional array, with the original voxels arranged in their correct
spatial positions inside of a 3-D "box" of empty voxels. This array can be
input directly into <code>lacunarity()</code> to generate lacunarity curves.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bounding_box(x, threshold = 0, edge_length = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A '<code>lac_voxels</code>' object created by <code>voxelize()</code> (preferred), or a
'<code>lasmetrics3d</code>' object created by <code>lidR::voxel_metrics()</code>. Users can
alternatively supply a <code>data.table</code> containing X, Y, Z,
and N columns, in which case the argument <code>edge_length</code> is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>An integer specifying the minimum number of points to use
when determining if a voxel is occupied. The default is <code>0</code>.
<code>bounding_box()</code> retains only those voxels where <code>x$N</code> is greater than
<code>threshold</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge_length</code></td>
<td>
<p>a numeric vector of length 3, specifying the X, Y, and Z
dimensions of each voxel. This argument should only be necessary when
supplying voxel data generated by a function other than <code>voxelize()</code> or
<code>lidR::voxel_metrics()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>bounding_box()</code> relies on the spatial coordinates of the input data
to determine the dimensions of the resulting array. Noisy point cloud data
will often produce "outlier" voxels surrounding points that are far removed
from the bulk of the point cloud. These can drastically alter the output,
creating an array in which the occupied voxels are surrounded by a large
region of empty space. It is highly recommended that users supply a cutoff
value for <code>threshold</code> to ideally remove these outliers. More elaborate
filtering tools for trimming the point data before voxelization are
available in the <code>lidR</code> package.
</p>


<h3>Value</h3>

<p>A 3-dimensional integer <code>array</code> containing values of <code>0</code>
or <code>1</code>, representing the occupancy of a given voxel. Occupied voxels (<code>1</code>)
are arranged according to their relative positions in 3-dimensional space,
and fully encapsulated within a rectangular volume of unoccupied voxels
(<code>0</code>). The XYZ positions of the voxels are retained in the array
<code>dimnames</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Basic usage ---------------------------------------------------------------
# simulate a diagonal line of points with XYZ coordinates
pc &lt;- data.frame(X = as.numeric(0:24), 
                 Y = as.numeric(0:24), 
                 Z = as.numeric(0:24))
# convert point data to cubic voxels of length 5
vox &lt;- voxelize(pc, edge_length = c(5,5,5))
# convert to voxel array
box &lt;- bounding_box(vox)

# Using lidR::voxel_metrics -------------------------------------------------
if (require("lidR")){
# reformat point data into rudimentary LAS object
las &lt;- suppressMessages(lidR::LAS(pc))
# convert to voxels of length 5
vox &lt;- lidR::voxel_metrics(las, ~list(N = length(Z)), res = 5)
# convert to voxel array
box &lt;- bounding_box(vox)
}

</code></pre>


</div>