<div class="container">

<table style="width: 100%;"><tr>
<td>kde</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kernel Density Estimation</h2>

<h3>Description</h3>

<p>Implements the (classical) kernel density estimator, see (2.2a) in  Silverman (1986).
</p>


<h3>Usage</h3>

<pre><code class="language-R">kde(xin, xout, h, kfun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xin</code></td>
<td>
<p>A vector of data points.  Missing values not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xout</code></td>
<td>
<p>A vector of grid points at which the estimate will be calculated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>A scalar, the bandwidth to use in the estimate, e.g. <code>bw.nrd(xin)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kfun</code></td>
<td>
<p>Kernel function to use. Supported kernels:  <code>Epanechnikov</code>,  <code>Biweight</code>,  <code>Gaussian</code>,  <code>Rectangular</code>,  <code>Triangular</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The classical kernel density estimator is given by
</p>
<p style="text-align: center;"><code class="reqn">\hat f(x;h) = n^{-1}\sum_{i=1}^n  K_h(x-X_{i})</code>
</p>

<p><code class="reqn">h</code> is determined by  a bandwidth selector such as Silverman's default plug-in rule.
</p>


<h3>Value</h3>

<p>A vector with the density estimates at the designated points xout.
</p>


<h3>Author(s)</h3>

<p>R implementation and documentation: Dimitrios Bagkavos &lt;dimitrios.bagkavos@gmail.com&gt;
</p>


<h3>References</h3>

<p>Silverman (1986), Density Estimation for Statistics and Data Analysis, Chapman and Hall, London.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x&lt;-seq(-5, 5,length=100)          #design points where the estimate will be calculated
plot(x, dnorm(x),  type="l", xlab = "x", ylab="density") #plot true density function
SampleSize &lt;- 100
ti&lt;- rnorm(SampleSize)            #draw a random sample from the actual distribution

huse&lt;-bw.nrd(ti)
arg2&lt;-kde(ti, x, huse, Epanechnikov) #Calculate the estimate
lines(x, arg2, lty=2)             #draw the result on the graphics device.
</code></pre>


</div>