<div class="container">

<table style="width: 100%;"><tr>
<td>lolog-terms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>LOLOG Model Terms</h2>

<h3>Description</h3>

<p>LOLOG Model Terms
</p>


<h3>Statistic Descriptions</h3>


<dl>
<dt>
<code>edges</code>  (dyad-independent)  (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p><em>Edges:</em> This term adds one network statistic equal to the number of edges 
(i.e. nonzero values) in the network. </p>
</dd>
<dt>
<code> star(k, direction="in")  </code> (order-independent) (directed)  (undirected)</dt>
<dd> 
<p>The <code>k</code> argument is a vector of distinct integers. 
This term adds one network statistic to the model for each element in <code>k</code>. 
The <code class="reqn">i</code>th such statistic counts the number of distinct <code>k[i]</code>-stars in the network, 
where a <code class="reqn">k</code>-star is defined to be a node <code class="reqn">N</code> and a set of <code class="reqn">k</code> different nodes 
<code class="reqn">\{O_1, \dots, O_k\}</code> such that the ties <code class="reqn">\{N, O_i\}</code> exist for <code class="reqn">i=1, \dots, k</code>. 
For directed networks, direction indicates whether the count is of in-stars (direction="in") 
or out-stars (direction="out")</p>
</dd>
<dt>
<code>triangles()</code> (order-independent) (directed)  (undirected)</dt>
<dd> 
<p>This term adds one statistic to the model equal to the number of triangles
in the network. For an undirected network, a triangle is defined to be any
set <code class="reqn">\{(i,j), (j,k), (k,i)\}</code> of three edges. For a directed network, a
triangle is defined as any set of three edges <code class="reqn">(i{\rightarrow}j)</code>
and <code class="reqn">(j{\rightarrow}k)</code> and either <code class="reqn">(k{\rightarrow}i)</code>
or <code class="reqn">(k{\leftarrow}i)</code>. </p>
</dd>
<dt>
<code>clustering()</code>  (order-independent) (undirected)</dt>
<dd> 
<p>The global clustering coefficient, defined as the number of triangles over the
number of possible triangles <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">https://en.wikipedia.org/wiki/Clustering_coefficient</a>, or
3 * triangles / 2-stars.
</p>
</dd>
<dt>
<code>transitivity()</code>  (order-independent) (undirected)</dt>
<dd> 
<p>The Soffer-Vazquez   transitivity. This is clustering metric that adjusts for large degree
differences and is described by C in Equation 6 of #' <a href="https://pubmed.ncbi.nlm.nih.gov/16089694/">https://pubmed.ncbi.nlm.nih.gov/16089694/</a>. Note 
The approximation of the number of possible shared neighbors between node i and j of min(d_i,d_j) - 1
in this implementation.
</p>
</dd>
<dt>
<code> mutual() </code> (order-independent) (directed)</dt>
<dd>
<p> A count of the number of pairs of actors 
<code class="reqn">i</code> and <code class="reqn">j</code> for which <code class="reqn">(i{\rightarrow}j)</code> and <code class="reqn">(j{\rightarrow}i)</code> 
both exist. 
</p>
</dd>
<dt>
<code> nodeMatch(name) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>For categorical network nodal variable 'name,' the number of edges between nodes with the same 
variable value.
</p>
</dd>
<dt>
<code> nodeMix(name) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>For categorical network nodal variable 'name,' adds one statistic for each combination of levels of the
variable equal to the count of edges between those levels.
</p>
</dd>
<dt>
<code> degree(d, direction="undirected", lessThanOrEqual=FALSE) </code> (order-independent)  (directed)  
(undirected)</dt>
<dd> 
<p>The <code>d</code> argument is a vector of distinct integers. This term adds one
network statistic to the model for each element in <code>d</code>; the <code class="reqn">i</code>th
such statistic equals the number of nodes in the network of degree
<code>d[i]</code>, i.e. with exactly <code>d[i]</code> edges.
For directed networks if direction="undirected"
degree is counted as the sum of the in and out degrees of a node. If direction="in" then in-degrees are
used and direction="out" indicates out-degrees.
</p>
<p>If lessThanOrEqual=TRUE, then the count is the number of nodes with degree less than or equal to d.
</p>
</dd>
<dt>
<code>twoPath</code> (order-independent) (directed)  (undirected)</dt>
<dd>
<p>This term adds one statistic to the model, equal to the number of 2-paths in
the network. For a directed network this is defined as a pair of edges
<code class="reqn">(i{\rightarrow}j), (j{\rightarrow}k)</code>, where <code class="reqn">i</code> and
<code class="reqn">j</code> must be distinct. That is, it is a directed path of length 2 from
<code class="reqn">i</code> to <code class="reqn">k</code> via <code class="reqn">j</code>. For directed networks a 2-path is also a
mixed 2-star.
For undirected networks a twopath is defined as a pair of edges
<code class="reqn">\{i,j\}, \{j,k\}</code>. That is, it is an undirected path of length 2 from
<code class="reqn">i</code> to <code class="reqn">k</code> via <code class="reqn">j</code>, also known as a 2-star.</p>
</dd>
<dt><code> degreeCrossProd() (order-independent)  (undirected) </code></dt>
<dd> 
<p>This term adds one network statistic equal to the mean of the cross-products
of the degrees of all pairs of nodes in the network which are tied.
</p>
</dd>
<dt>
<code> nodeCov(name) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>The <code>name</code> argument is a character string giving the name of a
numeric attribute in the network's vertex attribute list.
This term adds a single network statistic to the model equaling the sum of
<code>name(i)</code> and <code>name(j)</code> for all edges <code class="reqn">(i,j)</code> in the
network. For categorical variables, levels are coded as 1,..,nlevels'.
</p>
</dd>
<dt>
<code> edgeCov(x, name=NULL) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>The <code>x</code> argument is a square matrix of covariates, one for each possible edge in the network.
This term adds one statistic to the model, equal to the sum
of the covariate values for each edge appearing in the network. The
<code>edgeCov</code> term applies to both directed and undirected networks. For
undirected networks the covariates are also assumed to be undirected.
If present, the <code>name</code> argument is a character string providing a
name for the <code>edgeCov</code> term. The name will be "edgeCov.&lt;name&gt;". It is
recommended that all <code>edgeCov</code> terms be given explicit names. In particular,
if two unnamed <code>edgeCov</code> terms are supplied an error will occur (as they will
have the same default name "edgeCov.".
</p>
</dd>
<dt>
<code> edgeCovSparse(x, name=NULL) </code> (dyad-independent)  (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>Identical to edgeCov, except <code>x</code> should be a sparse matrix. This is especially useful for larger networks,
where passing a dense matrix to <code>edgeCov</code> is too memory intensive. 
</p>
</dd>
<dt>
<code>gwesp(alpha)</code>  (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>This term is just like <code>gwdsp</code> except it adds a statistic equal to the
geometrically weighted <em>edgewise</em> (not dyadwise) shared partner
distribution with decay parameter
<code>alpha</code> parameter, which should be non-negative.
</p>
</dd>
<dt>
<code> gwdegree(alpha, direction="undirected") </code>  (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>This term adds one network statistic to the model equal to the weighted
degree distribution with decay controlled by the <code>decay</code> parameter.
The <code>alpha</code> parameter is the same as theta_s in equation (14) in Hunter (2007).
</p>
<p>For directed networks if direction="undirected" degree is counted as the sum of the in and 
out degrees of a node. If direction="in" then in-degrees are used ans direction="out" 
indicates out-degrees.
</p>
</dd>
<dt>
<code> gwdsp(alpha) </code> (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>This term adds one network statistic to the model equal to the geometrically
weighted dyadwise shared partner distribution with decay parameter
<code>decay</code> parameter, which should be non-negative. 
</p>
</dd>
<dt>
<code> esp(d, type=2) </code> (order-independent)  (directed)  (undirected)</dt>
<dd> 
<p>This term adds one network
statistic to the model for each element in <code>d</code> where the <code class="reqn">i</code>th such
statistic equals the number of <em>edges</em> (rather than dyads) in the
network with exactly <code>d[i]</code> shared partners. This term can be used with
directed and undirected networks. For directed networks the count depends on type: 
</p>
<p>type = 1     :   from -&gt; to -&gt; nbr -&gt; from
</p>
<p>type = 2     :   from -&gt; to &lt;- nbr &lt;- from (homogeneous)
</p>
<p>type = 3     :   either type 1 or 2
</p>
<p>type = 4     :   all combinations of from -&gt; to &lt;-&gt; nbr &lt;-&gt; from
</p>
</dd>
<dt>
<code> geoDist(long, lat, distCuts=Inf) </code>(dyad-independent)  (order-independent)  (undirected)</dt>
<dd>  
<p>given nodal variables for longitude and latitude, calculates the sum of the
great circle distance between connected nodes. distCuts splits this into
separate statistics that count the sum of the minimum of the cut point and the
distance.
</p>
</dd>
<dt>
<code> dist(names </code> (dyad-independent)  (order-independent) (undirected)</dt>
<dd> 
<p>Calculates a statistic equal to the sum of the euclidean distances between
connected nodes on the numeric nodal variables specified in names.
</p>
</dd>
<dt>
<code> preferentialAttachment(k=1, direction="in") </code> (directed) (undirected)</dt>
<dd> 
<p>An order dependent preferential attachment term. For each edge, adds
</p>
<p>log( (k+degree) / (n * (meanDegree + k)))
</p>
<p>where degree is the current degree of the acting node, n is the network size, and meanDegree is
the mean degree of the network. This depends upon the order in which edges are added. For directed networks,
if direction="in" the in-degrees are used. If it is "out" the out degrees are used, otherwise "undirected"
means that the sum of the in and out degrees are used. 
</p>
</dd>
<dt>
<code> sharedNbrs(k=1) </code> (undirected)</dt>
<dd> 
<p>for each edge adds
</p>
<p>log(k + shared / minDeg)
</p>
<p>where shared is the current number of shared neighbors between the two nodes, and
minDeg is the minimum of the current degrees of the two nodes (i.e. the number of possible shared 
neighbors).
</p>
</dd>
<dt>
<code> nodeLogMaxCov(name) </code> (order-independent)  (undirected)</dt>
<dd> 
<p>For each edge (i,j) and nodal variable variable, add to the statistic
</p>
<p>log(max(variable[i],variable[j]))
</p>
<p>If the variable is a (partial) rank order of nodal inclusion into the network,
this statistic can be useful in modeling the mean degree over the course of the
growth process.
</p>
</dd>
<dt>
<code> nodeFactor(name, direction="undirected") </code> (order-independent)  (undirected) (directed)</dt>
<dd> 
<p>The <code>name</code> argument is a character vector giving
one or more names of categorical attributes in the network's vertex
attribute list. This term adds multiple network statistics to the
model, one for each of (a subset of) the unique values of the
<code>attrname</code> attribute (or each combination of the attributes
given). Each of these statistics gives the number of times a node
with that attribute or those attributes appears in an edge in the
network. In particular, for edges whose endpoints both have the same
attribute values, this value is counted twice.  For directed networks, if direction="in" then in-edges are
used and direction="out" indicates out-edges.
</p>
</dd>
<dt>
<code> absDiff(name, power=1) </code> (order-independent)  (undirected) (directed)</dt>
<dd> 
<p>The <code>name</code> argument is a character string giving the name
of one or mode quantitative attribute in the network's vertex attribute
list. This term adds one network statistic to the model equaling the
sum of <code>sum(abs(name[i]-name[j])^pow)</code> for all edges (i,j)
in the network. 
</p>
</dd>
</dl>
<h3>Constraint Descriptions</h3>


<dl>
<dt>
<code>boundedDegree(lower,upper)</code>  (order-independent)  (undirected)</dt>
<dd> 
<p>Adds a constraint that the degrees for the network must be between lower and upper.
</p>
</dd>
</dl>
</div>