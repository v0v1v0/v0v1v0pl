<div class="container">

<table style="width: 100%;"><tr>
<td>textstat_context</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identify context words using user-provided patterns</h2>

<h3>Description</h3>

<p>Identify context words using user-provided patterns
</p>


<h3>Usage</h3>

<pre><code class="language-R">textstat_context(
  x,
  pattern,
  valuetype = c("glob", "regex", "fixed"),
  case_insensitive = TRUE,
  window = 10,
  min_count = 10,
  remove_pattern = TRUE,
  n = 1,
  skip = 0,
  ...
)

char_context(
  x,
  pattern,
  valuetype = c("glob", "regex", "fixed"),
  case_insensitive = TRUE,
  window = 10,
  min_count = 10,
  remove_pattern = TRUE,
  p = 0.001,
  n = 1,
  skip = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a tokens object created by <code>quanteda::tokens()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p><code>quanteda::pattern()</code> to specify target words.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valuetype</code></td>
<td>
<p>the type of pattern matching: <code>"glob"</code> for "glob"-style
wildcard expressions; <code>"regex"</code> for regular expressions; or <code>"fixed"</code> for
exact matching. See <code>quanteda::valuetype()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>case_insensitive</code></td>
<td>
<p>if <code>TRUE</code>, ignore case when matching.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>size of window for collocation analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_count</code></td>
<td>
<p>minimum frequency of words within the window to be
considered as collocations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_pattern</code></td>
<td>
<p>if <code>TRUE</code>, keywords do not contain target words.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer vector specifying the number of elements to be concatenated
in each n-gram.  Each element of this vector will define a <code class="reqn">n</code> in the
<code class="reqn">n</code>-gram(s) that are produced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip</code></td>
<td>
<p>integer vector specifying the adjacency skip size for tokens
forming the n-grams, default is 0 for only immediately neighbouring words.
For <code>skipgrams</code>, <code>skip</code> can be a vector of integers, as the
"classic" approach to forming skip-grams is to set skip = <code class="reqn">k</code> where
<code class="reqn">k</code> is the distance for which <code class="reqn">k</code> or fewer skips are used to
construct the <code class="reqn">n</code>-gram.  Thus a "4-skip-n-gram" defined as <code>skip = 0:4</code> produces results that include 4 skips, 3 skips, 2 skips, 1 skip, and 0
skips (where 0 skips are typical n-grams formed from adjacent words).  See
Guthrie et al (2006).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>textstat_keyness()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>threshold for statistical significance of collocations.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>tokens_select()</code> and <code>textstat_keyness()</code>
</p>


</div>