<div class="container">

<table style="width: 100%;"><tr>
<td>ewspec3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute evolutionary wavelet spectrum of a time series.
</h2>

<h3>Description</h3>

<p>This function is a development of the <code>ewspec</code>
function from <code>wavethresh</code> but with more features.
The two new features are: the addition of running mean smoothing
and autoreflection which mitigates the problems caused in
<code>ewspec</code> which performed periodic transforms on
data (time series) which were generally not periodic. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">ewspec3(x, filter.number = 10, family = "DaubLeAsymm",
    UseLocalSpec = TRUE, DoSWT = TRUE, WPsmooth = TRUE,
    WPsmooth.type = "RM", binwidth = 5, verbose = FALSE,
    smooth.filter.number = 10, smooth.family = "DaubLeAsymm",
    smooth.levels = 3:WPwst$nlevels - 1, smooth.dev = madmad,
    smooth.policy = "LSuniversal", smooth.value = 0,
    smooth.by.level = FALSE, smooth.type = "soft",
    smooth.verbose = FALSE, smooth.cvtol = 0.01,
    smooth.cvnorm = l2norm, smooth.transform = I,
    smooth.inverse = I, AutoReflect = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The time series you want to compute the evolutionary
wavelet spectrum for.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.number</code></td>
<td>
<p>Wavelet filter number underlying the analysis
of the spectrum (see <code>filter.select</code> or <code>wd</code> for more
details).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Wavelet family. Again, see <code>filter.select</code> or <code>wd</code>
for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>UseLocalSpec</code></td>
<td>
<p> As <code>ewspec</code>, should usually leave as is.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DoSWT</code></td>
<td>
<p>As <code>ewspec</code>, should usually leave as is.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WPsmooth</code></td>
<td>
<p>If <code>TRUE</code> then smoothing is applied to
the wavelet periodogram (and hence spectrum).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WPsmooth.type</code></td>
<td>
<p>The type of periodogram smoothing. 
If this argument is <code>"RM"</code> then running mean
linear smoothing is used.
Otherwise, wavelet shrinkage as in <code>ewspec</code> is
used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binwidth</code></td>
<td>
<p>If the periodogram smoothing is <code>"RM"</code> then
the this argument supplies the <code>binwidth</code> or number
of consecutive observations used in the running mean smooth.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> then messages are produced. If 
<code>FALSE</code> then they are not.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.filter.number</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the index number of
wavelet to use, exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.family</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the family of
wavelet to use, exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.levels</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the levels to
smooth, exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.dev</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies  deviance used
to compute smoothing thresholds, exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.policy</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the policy
of wavelet shrinkage to use, exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.value</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the value of the
smoothing parameter for some policies, exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.by.level</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies whether level-by-level
thresholding is applied, or one threshold is applied to
all levels, exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.type</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the type of
thresholding, "hard" or "soft", exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.verbose</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies whether or not
verbose messages are produced during the smoothing,
exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.cvtol</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies a tolerance
for the cross-validation algorithm if it is specified
in the <code>smooth.policy</code>, exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.cvnorm</code></td>
<td>
<p>Ditto to the previous argument, but this
one supplies the norm used by the cross-validation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.transform</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies whether a transform
is used to transform the periodogram before smoothing, 
exactly as <code>ewspec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.inverse</code></td>
<td>
<p>Should be the mathematical inverse of
the <code>smooth.transform</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AutoReflect</code></td>
<td>
<p>Whether the series is internally reflected before
application of the wavelet transforms. So, <code>x</code> becomes
<code>c(x, rev(x))</code> which is a periodic sequence. After
estimation of the spectrum the second-half of the spectral
estimate is junked (because it is a reflection of the first
half). However, the estimate is better. This argument improves
over <code>ewspec</code> where poor estimates near boundaries were
obtained because the transforms assume periodicity but most
time series are not (and X_1 and X_T are very different, etc).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Precisely the same kind of output as <code>ewspec</code>.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code>AutoBestBW</code>, <code>lacf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#
# Generate time series
#
x &lt;- tvar1sim()
#
# Compute its evolutionary wavelet spectrum, with linear running mean smooth
#
x.ewspec3 &lt;- ewspec3(x)
#
# Plot the answer, probably its a bit variable, because the default bandwidth
# is 5, which is probably inappropriate for many series
#
## Not run: plot(x.ewspec3$S)
#
# Try a larger bandwidth
#
x.ewspec3 &lt;- ewspec3(x, binwidth=100)
#
# Plot the answer, should look a lot smoother
#
# Note, a lot of high frequency power on the right hand side of the plot,
# which is expected as process looks like AR(1) with param of -0.9
#
## Not run: plot(x.ewspec3$S)
#
# Do smoothing like ewspec (but additionally AutoReflect)
#
x.ewspec3 &lt;- ewspec3(x, WPsmooth.type="wavelet")
#
# Plot the results
#
## Not run: plot(x.ewspec3$S)
#
# Another possibility is to use AutoBestBW which tries to find the best
# linear smooth closest to a wavelet smooth. This makes use of ewspec3
#
</code></pre>


</div>