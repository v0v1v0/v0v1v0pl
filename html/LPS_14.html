<div class="container">

<table style="width: 100%;"><tr>
<td>predict.LPS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Predict method for LPS objects
</h2>

<h3>Description</h3>

<p>This function allow predictions to be made from a fitted <code>LPS</code> model and a new dataset.
</p>
<p>It can also plot a gene expression heatmap to visualize results of the prediction.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  ## S3 method for class 'LPS'
predict(object, newdata, type=c("class", "probability", "score"),
    method = c("Wright", "Radmacher", "exact"), threshold = 0.9, na.rm = TRUE,
    subset = NULL, col.lines = "#FFFFFF", col.classes = c("#FFCC00", "#1144CC"),
    plot = FALSE, side = NULL, cex.col = NA, cex.row = NA, mai.left = NA,
    mai.bottom = NA, mai.right = 1, mai.top = 0.1, side.height = 1, side.col = NULL,
    col.heatmap = heat(), zlim = "0 centered", norm = c("rows", "columns", "none"),
    norm.robust = FALSE, customLayout = FALSE, getLayout = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>An object of class <code>"LPS"</code>, as returned by <code>LPS</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>Continuous data used to retrieve classes, as a <code>data.frame</code> or <code>matrix</code>, with samples in rows and features (genes) in columns. Rows and columns should be named. It can also be a named numeric vector of already computed scores. <strong>Some precautions must be taken concerning data normalization, see the corresponding section in <code>LPS</code> manual page</strong>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>Single character value, return type of the predictions to be made ("class", "probability" or "score"). See 'Value' section.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>Single character value, the method to use to make predictions ("Wright", "Radmacher" or "exact"). See 'Details' section.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>

<p>Threshold to use for class prediction. "Wright" method was designed with 0.9, "Radmacher" method makes no use of the threshold.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>

<p>Single logical value, if TRUE samples with one or many <code>NA</code> features will be scored too (concerned feature is removed for the concerned sample, which might be discutable).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>A subsetting vector to apply on <code>newdata</code> rows. See <code>[</code> for handled values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.lines</code></td>
<td>

<p>If <code>graph</code> is TRUE, a single character value to be used for line drawing on the heatmap.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.classes</code></td>
<td>

<p>If <code>graph</code> is TRUE, a character vector of two values giving to each class a distinct color.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.col</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.row</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mai.left</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mai.bottom</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mai.right</code></td>
<td>

<p>To be passed to <code>heat.map</code> (used to plot score coefficients).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mai.top</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side.height</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side.col</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.heatmap</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlim</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.robust</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>customLayout</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getLayout</code></td>
<td>

<p>To be passed to <code>heat.map</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Ignored, just there to match the <code>predict</code> generic function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The "Compound covariate predictor" from Radmacher et al. (<code>method</code> = "Radmacher") simply assign each sample to the closest group (comparing the sample score to the mean scores of each group in the training dataset).
</p>
<p>The "Linear Predictor Score" from Wright et al. (<code>method</code> = "Wright") modelizes scores in each training sub-group with a distinct gaussian distribution, and computes the probability for a sample to be in one of them or the other using a bayesian rule.
</p>
<p>The "exact" mode is still under development and should not be used.
</p>


<h3>Value</h3>

<p>For a "class" <code>type</code>, returns a character vector with group assignment for each new sample (possibly <code>NA</code>), named according to <code>data</code> row names.
</p>
<p>For a "probability" <code>type</code>, returns a numeric matrix with two columns (probabilities to be in each group) and a row for each new sample, row named according to <code>data</code> row names and column named according to the group labels.
</p>
<p>For a "score" <code>type</code>, returns a numeric vector with LPS score for each new sample, named according to <code>data</code> row names. Notice the score is the same for all <code>method</code>s.
</p>
<p>If <code>plot</code> is <code>TRUE</code>, returns the list returned by <code>heat.map</code>, with data described above in the first unammed element.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mareschal
</p>


<h3>References</h3>

<p>Radmacher MD, McShane LM, Simon R. <cite>A paradigm for class prediction using gene expression profiles.</cite> J Comput Biol. 2002;9(3):505-11.
</p>
<p>Wright G, Tan B, Rosenwald A, Hurt EH, Wiestner A, Staudt LM. <cite>A gene expression-based method to diagnose clinically distinct subgroups of diffuse large B cell lymphoma.</cite> Proc Natl Acad Sci U S A. 2003 Aug 19;100(17):9991-6.
</p>


<h3>See Also</h3>

<p><code>LPS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Data with features in columns
  data(rosenwald)
  group &lt;- rosenwald.cli$group
  expr &lt;- t(rosenwald.expr)
  
  # NA imputation (feature's mean to minimize impact)
  f &lt;- function(x) { x[ is.na(x) ] &lt;- round(mean(x, na.rm=TRUE), 3); x }
  expr &lt;- apply(expr, 2, f)
  
  # Coefficients
  coeff &lt;- LPS.coeff(data=expr, response=group)
  
  # 10 best features model
  m &lt;- LPS(data=expr, coeff=coeff, response=group, k=10)
  
  
  # Class prediction plot
  predict(m, expr, plot=TRUE)
  
  # Wright et al. class prediction
  table(
    group,
    prediction = predict(m, expr),
    exclude = NULL
  )
  
  # More stringent threshold
  table(
    group,
    prediction = predict(m, expr, threshold=0.99),
    exclude = NULL
  )
  
  # Radmacher et al. class prediction
  table(
    group,
    prediction = predict(m, expr, method="Radmacher"),
    exclude = NULL
  )
  
  # Probabilities
  predict(m, expr, type="probability", method="Wright")
  predict(m, expr, type="probability", method="Radmacher")
  predict(m, expr, type="probability", method="exact")
  
  # Probability plot
  predict(m, expr, type="probability", plot=TRUE)
  
  # Annotated probability plot
  side &lt;- data.frame(group, row.names=rownames(expr))
  predict(m, expr, side=side, type="probability", plot=TRUE)
  
  # Score plot
  predict(m, expr, type="score", plot=TRUE)
</code></pre>


</div>