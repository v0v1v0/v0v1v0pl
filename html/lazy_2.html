<div class="container">

<table style="width: 100%;"><tr>
<td>lazy.control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set parameters for lazy learning</h2>

<h3>Description</h3>

<p>Set control parameters for a lazy learning object.</p>


<h3>Usage</h3>

<pre><code class="language-R">lazy.control(conIdPar=NULL, linIdPar=1, quaIdPar=NULL,
                distance=c("manhattan","euclidean"), metric=NULL,
                   cmbPar=1, lambda=1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>conIdPar</code></td>
<td>
<p>Parameter controlling the number of neighbors to be used
for identifying and validating constant models. <code>conIdPar</code> can assume
different forms:
</p>

<dl>
<dt>
<code>conIdPar=c(idm0,idM0,valM0)</code>:</dt>
<dd>
<p> In this case,
<code>idm0:idM0</code> is the range in which the best number of
neighbors is searched when identifying the local polynomial
models of degree 0 and where <code>valM0</code> is the maximum
number of neighbors used for their validation.  This means
that the constant models identified with <code>k</code> neighbors,
are validated on the first <code>v</code> neighbors, where
<code>v=min(k,valM0)</code>.  If <code>valM0=0</code>, <code>valM0</code> is set
to <code>idMO</code>: see next case for details.</p>
</dd>
<dt>
<code>conIdPar=c(idm0,idM0)</code>:</dt>
<dd>
<p> Here <code>idm0</code> and
<code>idM0</code> have the same role as in previous case, and
<code>valM0</code> is by default set to <code>idM0</code>: each model is
validated on all the neighbors used in identification.</p>
</dd>
<dt>
<code>conIdPar=p</code>:</dt>
<dd>
<p> Here <code>idmO</code> and <code>idMO</code> are
obtained according to the following formulas: <code>idm0=3</code>
and <code>idMX=5*p</code>. Recommended choice: <code>p=1</code>. As far as
the quantity <code>valM0</code> is concerned, it gets the default
value as in previous case.</p>
</dd>
<dt>
<code>conIdPar=NULL</code>:</dt>
<dd>
<p> No constant model is considered.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linIdPar</code></td>
<td>
<p>Parameter controlling the number of neighbors to be used
for identifying and validating linear models. <code>linIdPar</code> can assume
different forms:
</p>

<dl>
<dt>
<code>linIdPar=c(idm1,idM1,valM1)</code>:</dt>
<dd>
<p> In this case,
<code>idm1:idM1</code> is the range in which the best number of
neighbors is searched when identifying the local polynomial
models of degree 1 and where <code>valM1</code> is the maximum
number of neighbors used for their validation.  This means
that the linear models identified with <code>k</code> neighbors, are
validated on the first <code>v</code> neighbors, where
<code>v=min(k,valM1)</code>.  If <code>valM1=0</code>, <code>valM1</code> is set
to <code>idM1</code>: see next case for details.</p>
</dd>
<dt>
<code>linIdPar=c(idm1,idM1)</code>:</dt>
<dd>
<p> Here
<code>idm1</code> and <code>idM1</code> have the same role as in previous
case, and <code>valM1</code> is by default set to <code>idM1</code>: each
model is validated on all the neighbors used in identification.</p>
</dd>
<dt>
<code>linIdPar=p</code>:</dt>
<dd>
<p> Here <code>idmO</code> and <code>idMO</code> are
obtained according to the following formulas:
<code>idm1=3*noPar</code> and <code>idM1=5*p*noPar</code>, where
<code>noPar=nx+1</code> is the number of parameter of the polynomial
model of degree 1, and <code>nx</code> is the dimensionality of the
input space. Recommended choice: <code>p=1</code>. As far as the
quantity <code>valM1</code> is concerned, it gets the default value
as in previous case.</p>
</dd>
<dt>
<code>linIdPar=NULL</code>:</dt>
<dd>
<p> No linear model is considered.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quaIdPar</code></td>
<td>
<p>Parameter controlling the number of neighbors to be
used for identifying and validating quadratic
models. <code>quaIdPar</code> can assume different forms:
</p>

<dl>
<dt>
<code>quaIdPar=c(idm2,idM2,valM2)</code>:</dt>
<dd>
<p> In this case,
<code>idm2:idM2</code> is the range in which the best number of
neighbors is searched when identifying the local polynomial
models of degree 2 and where <code>valM2</code> is the maximum
number of neighbors used for their validation.  This means
that the quadratic models identified with <code>k</code> neighbors, are
validated on the first <code>v</code> neighbors, where
<code>v=min(k,valM2)</code>.  If <code>valM2=0</code>, <code>valM2</code> is set
to <code>idM2</code>: see next case for details.</p>
</dd>
<dt>
<code>quaIdPar=c(idm2,idM2)</code>:</dt>
<dd>
<p> Here
<code>idm2</code> and <code>idM2</code> have the same role as in previous
case, and <code>valM2</code> is by default set to <code>idM2</code>: each
model is validated on all the neighbors used in identification.</p>
</dd>
<dt>
<code>quaIdPar=p</code>:</dt>
<dd>
<p> Here <code>idmO</code> and <code>idMO</code> are
obtained according to the following formulas:
<code>idm2=3*noPar</code> and <code>idM2=5*p*noPar</code>, where in this
case the number of parameters is 
<code>noPar=(nx+1)*(nx+2)/2</code>, and <code>nx</code> is the
dimensionality of the input space. Recommended choice:
<code>p=1</code>. As far as the quantity <code>valM2</code> is concerned,
it gets the default value as in previous case.</p>
</dd>
<dt>
<code>quaIdPar=NULL</code>:</dt>
<dd>
<p> No quadratic model is considered.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>The distance metric: can be <code>manhattan</code> or
<code>euclidean</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>Vector of <code>n</code> elements. Weights used to evaluate
the distance between query point and neighbors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmbPar</code></td>
<td>
<p>Parameter controlling the local combination of
models. <code>cmbPar</code> can assume different forms:
</p>

<dl>
<dt>
<code>cmbPar=c(cmb0,cmb1,cmb2)</code>:</dt>
<dd>
<p> In this case, <code>cmbX</code>
is the number of polynomial models of degree <code>X</code> that will
be included in the local combination. Each local model will be
therfore a combination of <em>the best</em> <code>cmb0</code>
<em>models of degree 0, the best</em> <code>cmb1</code> <em>models of
degree 1, and the best</em> <code>cmb2</code> <em>models of degree 2</em>
identified as specified by <code>idPar</code>.</p>
</dd>
<dt>
<code>cmbPar=cmb</code>:</dt>
<dd>
<p> Here <code>cmb</code> is the number of models
that will be combined, disregarding any constraint on the
degree of the models that will be considered.  Each local model
will be therfore a combination of <em>the best</em> <code>cmb</code>
<em>models</em>, identified as specified by <code>id_par</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Initialization of the diagonal elements of the local
variance/covariance matrix for Ridge Regression.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The output of <code>lazy.control</code> is a list containing the
following components: <code>conIdPar</code>, <code>linIdPar</code>, <code>quaIdPar</code>,
<code>distance</code>, <code>metric</code>, <code>cmbPar</code>, <code>lambda</code>.
</p>


<h3>Author(s)</h3>

<p>Mauro Birattari and Gianluca Bontempi</p>


<h3>See Also</h3>

<p><code>lazy</code>, <code>predict.lazy</code></p>


</div>