<div class="container">

<table style="width: 100%;"><tr>
<td>Matrices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Matrix Utility Functions</h2>

<h3>Description</h3>

<p>These are utility functions for working with matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">as.indicator.matrix(x)
as.inverse(x)
as.parm.matrix(x, k, parm, Data, a=-Inf, b=Inf, restrict=FALSE, chol=FALSE)
as.positive.definite(x)
as.positive.semidefinite(x)
as.symmetric.matrix(x, k=NULL)
is.positive.definite(x)
is.positive.semidefinite(x)
is.square.matrix(x)
is.symmetric.matrix(x)
Cov2Cor(Sigma)
CovEstim(Model, parm, Data, Method="Hessian")
GaussHermiteCubeRule(N, dims, rule)
Hessian(Model, parm, Data, Interval=1e-6, Method="Richardson")
Jacobian(Model, parm, Data, Interval=1e-6, Method="simple")
logdet(x)
lower.triangle(x, diag=FALSE)
read.matrix(file, header=FALSE, sep=",", nrow=0, samples=0, size=0, na.rm=FALSE)
SparseGrid(J, K)
TransitionMatrix(theta.y=NULL, y.theta=NULL, p.theta=NULL)
tr(x)
upper.triangle(x, diag=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>This required argument accepts a positive integer that
indicates the number of nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>This is a matrix (though <code>as.symmetric.matrix</code> also
accepts vectors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J</code></td>
<td>
<p>This required argument indicates the dimension of the
integral and accepts a positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>For <code>as.parm.matrix</code>, this is a required argument,
indicating the dimension of the matrix. For
<code>as.symmetric.matrix</code>, this is an optional argument that
specifies the dimension of the symmetric matrix. This applies
only when <code>x</code> is a vector. It defaults to <code>NULL</code>,
in which case it calculates <code>k &lt;- (-1 + sqrt(1 + 8 *
      length(x)))/ 2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>This required argument indicates the accuracy and accepts a
positive integer. Larger values result in many more integration
nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the elements in the main
diagonal are also returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>This required argument indicates the dimension of the
integral and accepts a positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>This is a covariance matrix, <code class="reqn">\Sigma</code>, and may
be entered either as a matrix or vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Model</code></td>
<td>
<p>This is a model specification function. For more
information, see <code>LaplacesDemon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>This is a vector of parameters passed to the model
specification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Data</code></td>
<td>
<p>This is the list of data passed to the model
specification. For more information, see <code>LaplacesDemon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a,b</code></td>
<td>
<p>These optional arguments allow the elements of <code>x</code> to
be bound to the interval <code class="reqn">[a,b]</code>. For example, elements of a
correlation matrix are in the interval <code class="reqn">[-1,1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restrict</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then <code>x[1,1]</code> is
restricted to 1. This is useful in multinomial probit, for
example. The variable, <code>LaplacesDemonMatrix</code>, is
created in a new environment, <code>LDEnv</code> so <code>as.parm.matrix</code>
can keep track of changes from iteration to iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>This is an optional argument that accepts a univariate
Gauss-Hermite quadrature rule. Usually, this argument is left empty.
A rule may be supplied that differs from the traditional rule, such
as when constraints have been observed, and one or more nodes and
weights were adjusted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chol</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then x is an upper-triangular
matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>This is the name of the file from which the numeric data
matrix will be imported or read.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>header</code></td>
<td>
<p>Logical. When <code>TRUE</code>, the first row of the file
must contain names of the columns, and will be converted to the
column names of the numeric matrix. When <code>FALSE</code>, the first row
of the file contains data, not column names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Interval</code></td>
<td>
<p>This accepts a small scalar number for precision.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Method</code></td>
<td>
<p>This accepts a quoted string. For <code>Hessian</code>, it
defaults to <code>Method="Richardson"</code>, which uses Richardson
extrapolation. For <code>Jacobian</code>, it defaults to
<code>Method="simple"</code>, which uses finite-differencing. Richardson
Richardson extrapolation is more accurate, but slower to calculate.
Since error due to finite-differencing propagates through to higher
derivatives, finite-differencing should not be used when
approximating a Hessian matrix. Another method called automatic
differentiation is not currently available here, but should be more
accurate, though even slower to calculate. Another popular
alternative is to use the <code>BayesianBootstrap</code> on the
data. For <code>CovEstim</code>, this accepts <code>Method="Hessian"</code>,
<code>Method="Identity"</code> (which simply assigns an identity matrix),
<code>Method="OPG"</code> (which calculates the sum of outer products of
record-level gradients), or <code>Method="Sandwich"</code>, which is the
sandwich estimator and combines the Hessian and OPG estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow</code></td>
<td>
<p>This is the number of rows of the numeric matrix, and
defaults to <code>nrow=0</code>. If the number is known, the function will
perform noticeably faster when it does not have to check.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.theta</code></td>
<td>
<p>This accepts a matrix of prior probabilities for a
transition matrix, and defaults to <code>NULL</code>. If used, each row
must sum to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>
<p>This is the number of samples to take from the numeric
matrix. When <code>samples=0</code>, sampling is not performed and the
entire matrix is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>This argument indicates a character with which it will
separate fields when creating column vectors. For example, a
read a comma-separated file (.csv), use <code>sep=","</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>This is the batch size to be used only when reading a
numeric matrix that is larger than the available computer memory
(RAM), and only when <code>samples</code> is greater than zero. Sampling
of a big data matrix is performed by first determining the records
to keep, and then reading batches, one by one, and keeping the
matching records.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.y</code></td>
<td>
<p>This accepts a vector of posterior samples of a
discrete Markov chain, and defaults to <code>NULL</code>. If used, the
order of the samples affects the transition probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical. When <code>TRUE</code>, rows with missing values are
removed from the matrix after it is read. Rather than removing
missing values, the user may consider imputing missing values inside
the model, or before the model with the <code>MISS</code>
function. Examples of within-model imputation may be found in the
accompanying "Examples" vignette.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.theta</code></td>
<td>
<p>This accepts a vector of data that are samples of a
discrete distribution, and defaults to <code>NULL</code>. If used, the
order of the samples affects the transition probability.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>as.indicator.matrix</code> function creates an indicator matrix
from a vector. This function is useful for converting a discrete
vector into a matrix in which each column represents one of the
discrete values, and each occurence of that value in the related
column is indicated by a one, and is otherwise filled with
zeroes. This function is similar to the <code>class.ind</code> function in
the nnet package.
</p>
<p>The <code>as.inverse</code> function returns the matrix inverse of
<code>x</code>. The <code>solve</code> function in base R also returns the matrix
inverse, but <code>solve</code> can return a matrix that is not symmetric,
and can fail due to singularities. The <code>as.inverse</code> function
tries to use the <code>solve</code> function to return a matrix inverse, and
when it fails due to a singularity, <code>as.inverse</code> uses eigenvalue
decomposition (in which eigenvalues below a tolerance are replaced
with the tolerance), and coerces the result to a symmetric
matrix. This is similar to the <code>solvcov</code> function in the fpc
package.
</p>
<p>The <code>as.parm.matrix</code> function prepares a correlation, covariance,
or precision matrix in two important ways. First,
<code>as.parm.matrix</code> obtains the parameters for the matrix specified
in the <code>x</code> argument by matching the name of the matrix in the
<code>x</code> argument with any parameters in <code>parm</code>, given the
parameter names in the <code>Data</code> listed in <code>parm.names</code>. These
obtained parameters are organized into a matrix as the elements of the
upper-triangular, including the diagonal. A copy is made, without the
diagonal, and the lower-triangular is filled in, completing the
matrix. Second, <code>as.parm.matrix</code> checks for
positive-definiteness. If matrix <code>x</code> is positive-definite, then
the matrix is stored as a variable called <code>LaplacesDemonMatrix</code>
in a new environment called <code>LDEnv</code>. If matrix <code>x</code> is not
positive-definite, then <code>LaplacesDemonMatrix</code> in <code>LDEnv</code> is
sought as a replacement. If this variable exists, then it is used to
replace the matrix. If not, then the matrix is replaced with an
identity matrix. Back in the model specification, after using
<code>as.parm.matrix</code>, it is recommended that the user also pass the
resulting matrix back into the <code>parm</code> vector, so the sampler or
algorithm knows that the elements of the matrix have changed.
</p>
<p>The <code>as.positive.definite</code> function returns the nearest
positive-definite matrix for a matrix that is square and symmetric
(Higham, 2002). This version is intended only for covariance and
precision matrices, and has been optimized for speed. A more
extensible function is <code>nearPD</code> in the matrixcalc package, which
is also able to work with correlation matrices, and matrices that are
asymmetric.
</p>
<p>The <code>as.positive.semidefinite</code> function iteratively seeks to
return a square, symmetric matrix that is at least
positive-semidefinite, by replacing each negative eigenvalue and
calculating its projection. This is intended only for covariance and
precision matrices. A similar function is <code>makePsd</code> in the RTAQ
package, though it is not iterative, and returns matrices that fail a
logical check with <code>is.positive.semidefinite</code>.
</p>
<p>The <code>as.symmetric.matrix</code> function accepts either a vector or
matrix, and returns a symmetric matrix. In the case of a vector, it
can be either all elements of the matrix, or the lower triangular. In
the case of a <code>x</code> being entered as a matrix, this function
tolerates non-finite values in one triangle (say, the lower), as long
as the corresponding element is finite in the other (say, the upper)
triangle.
</p>
<p>The <code>Cov2Cor</code> function converts a covariance matrix into a
correlation matrix, and accepts the covariance matrix either in matrix
or vector form. This function may be useful inside a model
specification and also with converting posterior draws of the elements
of a covariance matrix to a correlation matrix. <code>Cov2Cor</code> is an
expanded form of the <code>cov2cor</code> function in the <code>stats</code>
package, where <code>Cov2Cor</code> is also able to accept and return a
vectorized matrix.
</p>
<p>The <code>CovEstim</code> function estimates a covariance matrix with one of
several methods. This is mainly used by
<code>LaplaceApproximation</code>, where the <code>parm</code> argument
receives the posterior modes. See the <code>CovEst</code> argument for
more details.
</p>
<p>The <code>GaussHermiteCubeRule</code> function returns a matrix of nodes and
a vector of weights for a <code>dims</code>-dimensional integral given
<code class="reqn">N</code> univariate nodes. The number of multivariate nodes will differ
from the number of univariate nodes. This function is for use with
multivariate quadrature, often called cubature. This has been adapted
from the <code>multiquad</code> function in the NominalLogisticBiplot
package. The <code>GaussHermiteQuadRule</code> function is a
univariate version. A customized univariate <code>rule</code> may be
supplied when constraints necessitate that one or more nodes and
weights had to be altered.
</p>
<p>The <code>Hessian</code> returns a symmetric, Hessian matrix, which is a
matrix of second partial derivatives. The estimation of the Hessian
matrix is approximated numerically using Richardson extrapolation by
default. This is a slow function. This function is not intended to be
called by the user, but is made available here. This is essentially
the <code>hessian</code> function from the numDeriv package, adapted to
Laplace's Demon.
</p>
<p>The <code>is.positive.definite</code> function is a logical test of whether
or not a matrix is positive-definite. A <code class="reqn">k \times k</code>
symmetric matrix <code class="reqn">\textbf{X}</code> is positive-definite if all of
its eigenvalues are positive (<code class="reqn">\lambda_i &gt; 0, i \in k</code>). All main-diagonal elements must be positive. The
determinant of a positive-definite matrix is always positive, so a
positive-definite matrix is always nonsingular. Non-symmetric,
positive-definite matrices exist, but are not considered here.
</p>
<p>The <code>is.positive.semidefinite</code> function is a logical test of
whether or not a matrix is positive-semidefinite. A <code class="reqn">k x k</code>
symmetric matrix <code class="reqn">\textbf{X}</code> is positive-semidefinite if all
of its eigenvalues are non-negative (<code class="reqn">\lambda_i \ge 0, i \in
  k</code>).
</p>
<p>The <code>is.square.matrix</code> function is a logical test of whether or
not a matrix is square. A square matrix is a matrix with the same
number of rows and columns, and is usually represented as a <code class="reqn">k
  \times k</code> matrix <code class="reqn">\textbf{X}</code>.
</p>
<p>The <code>is.symmetric.matrix</code> function is a logical test of whether
or not a matrix is symmetric. A symmetric matrix is a square matrix
that is equal to its transpose, <code class="reqn">\textbf{X} = \textbf{X}^T</code>. For example, where <code class="reqn">i</code> indexes rows and <code class="reqn">j</code> indexes
columns, <code class="reqn">\textbf{X}_{i,j} = \textbf{X}_{j,i}</code>. This differs from the <code>isSymmetric</code> function in base R
that is inexact, using <code>all.equal</code>.
</p>
<p>The <code>Jacobian</code> function estimates the Jacobian matrix, which is
a matrix of all first-order partial derivatives of the <code>Model</code>.
The Jacobian matrix is estimated by default with forward
finite-differencing, or optionally with Richardson extrapolation. This
function is not intended to be called by the user, but is made
available here. This is essentially the <code>jacobian</code> function from
the numDeriv package, adapted to LaplacesDemon.
</p>
<p>The <code>logdet</code> function returns the logarithm of the determinant of
a positive-definite matrix via the Cholesky decomposition. The
determinant is a value associated with a square matrix, and was used
historically to <em>determine</em> if a system of linear equations has a
unique solution. The term <em>determinant</em> was introduced by Gauss,
where Laplace referred to it as the resultant. When the determinant is
zero, the matrix is singular and non-invertible; there are either no
solutions or many solutions. A unique solution exists when the
determinant is non-zero. The <code>det</code> function in base R works well
for small matrices, but can return erroneously return zero in larger
matrices. It is better to work with the log-determinant.
</p>
<p>The <code>lower.triangle</code> function returns a vector of the lower
triangular elements of a matrix, and the diagonal is included when
<code>diag=TRUE</code>.
</p>
<p>The <code>read.matrix</code> function is provided here as one of many
convenient ways to read a numeric matrix into R. The most common
method of storing data in R is the data frame, because it is
versatile. For example, a data frame may contain character, factor,
and numeric variables together. For iterative estimation, common in
Bayesian inference, the data frame is much slower than the numeric
matrix. For this reason, the LaplacesDemon package does not use data
frames, and has not traditionally accepted character or factor
data. The <code>read.matrix</code> function returns either an entire numeric
matrix, or row-wise samples from a numeric matrix. Samples may be
taken from a matrix that is too large for available computer memory
(RAM), such as with big data.
</p>
<p>The <code>SparseGrid</code> function returns a sparse grid for a
<code class="reqn">J</code>-dimensional integral with accuracy <code class="reqn">K</code>, given
Gauss-Hermite quadrature rules. A grid of order eqnK provides an
exact result for a polynomial of total order of <code class="reqn">2K - 1</code> or less.
<code>SparseGrid</code> returns a matrix of nodes and a vector of weights.
A sparse grid is more efficient than the full grid in the
<code>GaussHermiteCubeRule</code> function. This has been adapted from the
SparseGrid package.
</p>
<p>The <code>TransitionMatrix</code> function has several uses. A user may
supply a vector of marginal posterior samples of a discrete Markov
chain as <code>theta.y</code>, and an observed posterior transition matrix
is returned. Otherwise, a user may supply data (<code>y.theta</code>) and/or
a prior (<code>p.theta</code>), in which case a posterior transition matrix
is returned. A common row-wise prior is the dirichlet distribution.
Transition probabilities are from row element to column element.
</p>
<p>The <code>tr</code> function returns the trace of a matrix. The trace of a
matrix is the sum of the elements in the main diagonal of a square
matrix. For example, the trace of a <code class="reqn">k \times k</code> matrix
<code class="reqn">\textbf{X}</code>, is <code class="reqn">\sum_{k=1} \textbf{X}_{k,k}</code>.
</p>
<p>The <code>upper.triangle</code> function returns a vector of the lower
triangular elements of a matrix, and the diagonal is included when
<code>diag=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Statisticat, LLC. <a href="mailto:software@bayesian-inference.com">software@bayesian-inference.com</a></p>


<h3>References</h3>

<p>Higham, N.J. (2002). "Computing the Nearest Correlation Matrix - a
Problem from Finance". <em>IMA Journal of Numerical Analysis</em>, 22,
p. 329â€“343.
</p>


<h3>See Also</h3>

<p><code>BayesianBootstrap</code>,
<code>Cov2Prec</code>,
<code>cov2cor</code>,
<code>ddirichlet</code>,
<code>GaussHermiteQuadRule</code>,
<code>isSymmetric</code>,
<code>LaplaceApproximation</code>,
<code>LaplacesDemon</code>,
<code>lower.tri</code>,
<code>MISS</code>,
<code>Prec2Cov</code>,
<code>solve</code>, and
<code>upper.tri</code>.
</p>


</div>