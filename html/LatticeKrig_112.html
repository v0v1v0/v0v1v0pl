<div class="container">

<table style="width: 100%;"><tr>
<td>LKrigSetup</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Create or update the LatticeKrig model object (LKinfo) for spatial fitting. 
</h2>

<h3>Description</h3>

<p>This function combines some input arguments with defaults for other
to create a list 
describing the LatticeKrig spatial model. A key to specifying the LatticeKrig
spatial model is specifying the geometry, e.g. LKRectangle for a 2-d rectangular
domain. Each geometry has some parameters that control the basic model setup and
these are included through the ... arguments of  this function. See the help for
this argument below for some examples.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LKrigSetup(x = NULL, nlevel = NULL, alpha = NA, alphaObject =
                 NULL, nu = NULL, a.wght = NA, a.wghtObject = NULL, NC
                 = NULL, NC.buffer = NULL,delta = delta, normalize = TRUE,
                 normalizeMethod = 
                 "exact", lambda = NA, tau = NA, sigma2 = NA, sigma2.object = NULL,
                 latticeInfo = NULL, basisInfo = NULL, LKGeometry =
                 "LKRectangle", distance.type = "Euclidean",
                 BasisFunction = "WendlandFunction", overlap = 2.5, V =
                 NULL, BasisType = "Radial", fixedFunction =
                 "LKrigDefaultFixedFunction", fixedFunctionArgs =
                 list(m = 2), collapseFixedEffect = FALSE, max.points =
                 NULL, mean.neighbor = 50, choleskyMemory = NULL,
                 verbose = FALSE, noCheck = FALSE, returnCall = FALSE,
                 dense = FALSE, ...)
                 
LatticeKrigEasyDefaults(argList, nlevel, x)

LKinfoUpdate(LKinfo, ... )
</code></pre>


<h3>Arguments</h3>

	
<table>
<tr style="vertical-align: top;">
<td><code>argList</code></td>
<td>
<p>Argument supplied to the top level LatticeKrig function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A vector of length <code>nlevel</code> with the relative
variances for the different multi-resolution levels.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaObject</code></td>
<td>
<p>For non-stationary models an object to be used 
with the predict function to give the alpha values at the process
locations.Typically this is a list of "predict" objects. 
See nonstationaryModels for examples how to use this option. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.wght</code></td>
<td>
<p>This parameter controls the correlation range in the SAR
model. In most cases, a scalar value and for the 2-d model by default
greater than 4. 
If a vector this can specify an anisotropic set of weights. To
specify a.wght parameters that are different for each level they
should be in the form of a list 
of length <code>nlevel</code>. E.g.  <code>a.wght = list( 4.5, 5, 10)</code>
will specify different a.wghts for 3 different levels.   The setup
function will
check that the values are in a valid range for a geometry and the
length of the list agrees with the number of levels. 
</p>
<p>The details of how this is connected to the covariance function
varies
based on the geometry. However, qualitatively this is related to a
range parameter. For the LKRectangle geometry and a stationary
model,  at level k the center point has
weight 1 with the 4 nearest neighbors given weight
-1/a.wght[k]. In this case a.wght must be greater than 4 for the
fields to be
stationary and following Lindgren and Rue the range parameter is
approximately <code>1/sqrt(a.wght-4)</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.wghtObject</code></td>
<td>
<p>For non-stationary models an object to be used 
with the predict function to give the a.wght values at the lattice locations.
See nonstationaryModels for examples how to used option. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basisInfo</code></td>
<td>
<p> A list with extra components the object used to
describe the multi-resolution basis.  Usually this will not be
needed for standard models. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BasisType</code></td>
<td>
<p>A character string indicating the type of basis function. Currently
this is either <code>"Radial"</code> or <code>"Tensor"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choleskyMemory</code></td>
<td>
<p>A list that will be used in the spam call to 
do the Cholesky decomposition. See the <code>memory</code> argument in 
<code>chol.spam</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapseFixedEffect</code></td>
<td>
<p>If FALSE the fixed part of the model is
found separately for each replicated data set. If TRUE the estimate is
polled across replicates.This is largely a modeling decision whether
variation among the replicate fields is due to the spatial component or
also include variation in the fixed effects across replicates â€“ guess
they are not really fixed then!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>A vector that will be used for the basis center spacings. This 
is an alternative choice to <code>NC</code>. Note that all the spacings need 
to be specified as a vector with length <code>nlevel</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dense</code></td>
<td>
<p>If FALSE sparse linear algebra is used for the
computations
. If TRUE the matrices are
made "dense" (zeroes are filled in) and the ordinary Lapack functions
are used for the linear algebra.
This option is primarily
for testing and timing sparse verses standard algorithms. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance.type</code></td>
<td>
<p>A text string indicate type distance to use
between spatial locations when evaluating the basis
functions. Default is "Euclidean". Other choices when
locations are in degrees longitude and latitude are "Chordal"
and "GreatCircle" with the default units being miles. See Details below
how to change the radius that is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedFunction</code></td>
<td>
<p>A text string that is the name of the function
used to find the fixed part of the spatial model based on the
locations. The default is a linear (m=2) polynomial in the
spatial coordinates. See <code>LKrigDefaultFixedFunction</code> for more details.
Set this to NULL if you do not want to
include a fixed effect in the spatial model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedFunctionArgs</code></td>
<td>
<p>A list containing arguments to supply when
evaluating the fixed function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> The "noise to signal ratio" or also known as the
smoothing parameter it is the parameter <code>lambda =
  	tau^2/sigma2</code>. If specified then tau and sigma2 typically are
estimated in LKrig by maximum likelihood. If lambda is not
specified then it is set as <code>lambda = tau^2/ sigma2</code>. Note
that to evaluate the spatial process model, e.g. using the
function <code>LKrig.cov</code>, a value of lambda is not needed and
this argument can default to NA.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latticeInfo</code></td>
<td>
<p> Part
or all of the object used to describe the Markov random field
lattice.  In the standard cases this list is created in the
setup function and need not be specified. See
<code>LKrigSetupLattice</code> for details. Note that the contents
of this list is concatenated to any additional components
supplied by <code>LKrigSetupLattice</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LKGeometry</code></td>
<td>
<p> A text string that gives the names of the model
geometry.  The default is "LKrectangle" assuming the 
spatial domain is a rectangle.  Other common choices are
"LKInterval" (1 d problem ) and "LKBox" (for a 3d problem).
See LKGeometry for more detials. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LKinfo</code></td>
<td>
<p>A list that has class "LKinfo".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.neighbor</code></td>
<td>
<p> The average number of nonzero points when each
basis function is evaluated at a set of points points in the spatial
domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.points</code></td>
<td>
<p>This is a parameter for the nearest neighbor
distance function that sets the maximum array size for the
nonzero distances among points.  e.g. with 100 points each
with 20 nonzero neighbors max.points needs to be 2000 =
100*20. Specifically if the total number of nonzero values
when each basis function is evaluated at all the spatial
locations. The easier way to specify space is by using the
mean.neighbor argument.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NC</code></td>
<td>
<p>For regular grids of lattice points the maximum number of 
lattice grid points for a spatial coordinate and at the coarsest level 
of resolution. For a example, for a square region,
(and <code>LKGeometry = "LKRectangle"</code>)
<code>NC=5</code> results in a 5X5  = 25  lattice points at the first level.
Note that the default is that lattice points are also taken to have 
the same spacing in every dimension. See the <code>delta</code> argument as an
alternative way to specify the basis centers. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NC.buffer</code></td>
<td>
<p>Number of extra lattice points added outside the 
spatial domain 
for regular grids of lattice points. This helps to reduce boundary 
effects from the
SAR model.  <code>NC.buffer=5</code> and <code>NC=5</code> for a square region 
will result in 
(5+ 2*5) X (5+ 2*5) = 225 lattice locations at the coarsest level 
of resolution.
Note that this number by default is fixed for finer resolutions and 
so does not
contribute as much to the total number of lattice points.
This option works for either <code>NC</code> or <code>delta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlevel</code></td>
<td>
<p>Number of levels in
multi-resolution. Note that each subsequent level increases the
number of basis functions within the spatial domain size by a
factor of roughly 4. But not exactly 4!  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noCheck</code></td>
<td>
<p>If FALSE do not make any checks on the consistency of
the different parts of the final LKinfo object. e.q. values of
a.wght within the range of a stationary Markov random field. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p> If TRUE the basis functions will be normalized to
give a marginal variance of one for each level of
multi-resolution.  (Normalizing by levels makes it easier to
interpret the <code>alpha</code> weights.)  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalizeMethod</code></td>
<td>
<p> Options are <code>"exact"</code>, <code>"exactKronecker"</code>,
<code>"fftInterpolation"</code>, and <code>"both"</code>. The <code>"exact"</code>" option
calculates the exact marginal variance but slowly, while
<code>"exactKronecker"</code> can offer a speedup in scenarios with a constant
a.wght and rectangular geometry. <code>"fftInterpolation"</code> offers
an ever faster but approximate calculation, and can only be used in 
situations where the number of locations significantly exceeds th
e number of basis functions. The <code>"both"</code> method
automatically uses the FFT approximation for lower levels, and switches
to the Kronecker method 
when the number of basis functions grows to be too large for the
approximate method. See 
<code>LKrigNormalizeBasis</code> for more detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p> A
smoothness parameter that controls relative sizes of
<code>alpha</code>.  Currently this parameter only makes sense for
the 2D rectangular domain (LKRectangle) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlap</code></td>
<td>

<p>Controls the overlap among the radial basis functions and
should be in units of the lattice spacing. For the rectangular
case the default of 2.5 means that the support of the Wendland
basis function will overlap 2.5 lattice units in each
direction.  See <code>LKrig.basis</code> for how overlap adjusts
scaling in the basis function formula. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p> A scalar, the sill or marginal variance of the process.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BasisFunction</code></td>
<td>
<p>Text string giving the 1-d form for
basis function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2.object</code></td>
<td>
<p> A prediction object to specify part of the
marginal variance for the process. Specifically the form is
VAR(g(x1))= sigma2*h(x1) Calling <code>predict(sigma2.object,x1)</code>
should return a vector with the values of h at the (arbitrary)
spatial locations in x1.  If omitted assumed to be the
constant one â€“ the usual case.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnCall</code></td>
<td>
<p>If TRUE the call to LKrigSetup is also included as
part of the LKinfo object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p> The measurement error standard deviation.  Also called
the nugget variance in geostatistics.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>See entry in <code>LKrig</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If TRUE print out intermediate information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Spatial locations that define the spatial domain for
prediction. This is only used to determine ranges of the grid for the basis
functions so, for example, for a rectangular domain only two points
are required that bound the rest of the data locations. E.g.  x=
rbind( c( 0,0), c(1,1)) will set the domain to be the unit square.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Specific arguments that will be included in the
<code>setupArgs</code> list and also passed to
LKrigSetupLattice
. For LKinfoUpdate these specify the components
of LKinfo to update. For example for a rectangular domain (the default)
the argument <code>NC</code> is needed to specify the initial lattice size 
<code>NC.buffer</code> sets the number of extra points included in the
lattice and defaults to 5.  <code>NC</code> for the LKSphere geometry  
is the initial level of the
icosahedral grid.   </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Many of the functions within LKrigSetup are overloaded to
adapt to the <code>LKGeometry</code> class.  This makes it easy to add new
geometries or other models to the LatticeKrig framework.  The
required components of this object (see below) outline how
the latticeKrig model is structured and what should be common
features independent of the geometry. The key components are:
</p>
<p><code>basisInfo</code> used to specify the form of the  basis functions (see LKrig.basis)
</p>
<p><code>latticeInfo</code> that contains the information used to generate the
spatial autoregressive matrix on the lattice.
See (LKrigSetupLattice for the top level function that sets up the lattice. 
</p>
<p><code>a.wght</code> A component that specifies the weights in the SAR model. (See LKrigSetupAwght)
</p>
<p><code>alpha</code> A component that gives the relative weights of the different
layers for a multiresolution model. (See
LKrigSetupAlpha.)
</p>
<p>Also part of this flexibility is to use different distance functions
(metrics). See help on <code>LKDistance</code> for the S4 method to
find the distance
and 
LKDist for the lower level functions that actually do the work. 
To change the radius used for the spherical distances one can add a <code>Radius</code>
attribute to the text string. 
For example to use kilometers  for great circle distance ( R approximately 6371)
</p>
<pre>
   dtype &lt;- "GreatCircle" 
   attr( dtype, which="Radius") &lt;- 6371 
   </pre> 
<p>Now use <code>distance.type = dtype</code>for the distance type argument. 
</p>
<p>The function LKrigEasyDefaults is used in the top level 
function LattticeKrig to make the logic of different default choices 
more readable and reduces the clutter in this function. Its main 
purpose is to find a reasonable choice for NC when this is not
specified. 
</p>
<p>As example of how the computation is structured with the complete
<code>LKinfo</code> object 
LKrigSAR can be called to generate the sparse SAR matrix of the basis function coefficients at a given level of resolution:
</p>
<pre>
  B1&lt;- LKrigSAR(LKinfo, Level=1)
	</pre>
<p>The basis function matrix can be evaluated at a matrix of locations $<code>x1</code> as 
</p>
<pre>
	Phi&lt;- LKrig.basis( x1,LKinfo)
	</pre>
<p>The function LKinfoUpdate is more of a utility used for
clarity that allows one to update the LKinfo object with
particular components without having to recreate the entire
object. This function is used in the MLE search when just
values of alpha or a.wght are being varied.
</p>


<h3>Value</h3>

<p>An object with class "LKinfo" and also the additional class given by 
LKGeometry. The required components are:
</p>

<dl>
<dt>nlevel</dt>
<dd>
<p> Number of levels</p>
</dd>
<dt>alpha</dt>
<dd>
<p>alpha parameters as a list that has  nlevel components and possibly some attributes. </p>
</dd>
<dt>a.wght</dt>
<dd>
<p>a.wght parameters as a list that has  nlevel components and possibly some attributes. </p>
</dd>
<dt>nu</dt>
<dd>
<p>nu parameter</p>
</dd>
<dt>normalize</dt>
<dd>
<p>A logical indicating whether to normalize.</p>
</dd>
<dt>normalizeMethod</dt>
<dd>
<p>A string that determines the method for normalization.</p>
</dd>
<dt>lambda</dt>
<dd>
<p> Value of lambda.</p>
</dd>
<dt>tau</dt>
<dd>
<p>Value of tau.</p>
</dd>
<dt>sigma2</dt>
<dd>
<p>Value for sigma2.</p>
</dd>
<dt>sigma2.object</dt>
<dd>
<p>Value for sigma2.object.</p>
</dd>
<dt>latticeInfo</dt>
<dd>
<p>A list with specific multi-resolution lattice information</p>
</dd>
<dt>setupArgs</dt>
<dd>
<p>All arguments passed in the call and any in in ... </p>
</dd>
<dt>basisInfo</dt>
<dd>
<p>A list with basis information.</p>
</dd>
<dt>call</dt>
<dd>
<p>The actual call used to create this object.</p>
</dd>	 
</dl>
<h3>Author(s)</h3>

<p>Doug Nychka
</p>


<h3>Examples</h3>

<pre><code class="language-R">  data(ozone2)
  # find the ranges of the  data, this is the same as passing
  # the entire set of observation locations and is more compact 
  sDomain&lt;-apply( ozone2$lon.lat, 2,"range")
  LKinfo0&lt;- LKrigSetup( sDomain, NC=10, nlevel=2, alpha=c(1,.5),
                       a.wght = 5)
  print( LKinfo0)
  
  #Gigantic buffer added note extra basis functions. 
  LKinfo&lt;- LKrigSetup( sDomain, NC=10, NC.buffer= 15, nlevel=2, 
  alpha=c(1,.5),a.wght = 5)
  print( LKinfo)
  
  LKinfo2&lt;- LKinfoUpdate( LKinfo,  a.wght=4.1, NC=12)
  LKinfo3&lt;- LKrigSetup( sDomain, NC=12, nlevel=2, alpha=c(1,.5),
                        a.wght=4.1)
# LKinfo2 and LKinfo3 should be the same.                         
 
</code></pre>


</div>