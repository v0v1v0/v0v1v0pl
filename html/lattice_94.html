<div class="container">

<table style="width: 100%;"><tr>
<td>F_2_llines</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Replacements of traditional graphics functions</h2>

<h3>Description</h3>

<p>These functions are intended to replace common low level traditional
graphics functions, primarily for use in panel functions.  The
originals can not be used (at least not easily) because lattice panel
functions need to use grid graphics.  Low level drawing functions in
grid can be used directly as well, and is often more flexible.  These
functions are provided for convenience and portability.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lplot.xy(xy, type, pch, lty, col, cex, lwd,
         font, fontfamily, fontface,
         col.line, col.symbol, alpha, fill,
         origin = 0, ..., identifier, name.type)

larrows(...)
llines(x, ...)
lpoints(x, ...)
lpolygon(x, ...)
lpolypath(x, ...)
lrect(...)
lsegments(...)
ltext(x, ...)

## Default S3 method:
larrows(x0 = NULL, y0 = NULL, x1, y1, x2 = NULL, y2 = NULL,
        angle = 30, code = 2, length = 0.25, unit = "inches",
        ends = switch(code, "first", "last", "both"),
        type = "open",
        col = add.line$col,
        alpha = add.line$alpha,
        lty = add.line$lty,
        lwd = add.line$lwd,
        fill = NULL, 
        font, fontface,
        ..., identifier, name.type)
## Default S3 method:
llines(x, y = NULL, type = "l",
        col, alpha, lty, lwd, ..., identifier, name.type)
## Default S3 method:
lpoints(x, y = NULL, type = "p", col, pch, alpha, fill,
        font, fontfamily, fontface, cex, ..., identifier, name.type) 
## Default S3 method:
lpolygon(x, y = NULL,
        border = "black", col = "transparent", fill = NULL, 
        font, fontface,
        ...,
        rule = c("none", "winding", "evenodd"),
        identifier, name.type)        
## Default S3 method:
lpolypath(x, y = NULL,
         border = "black", col = "transparent", fill = NULL, 
         font, fontface,
         ...,
         rule = c("winding", "evenodd"),
         identifier, name.type)        
## Default S3 method:
ltext(x, y = NULL, labels = seq_along(x),
        col, alpha, cex, srt = 0,
        lineheight, font, fontfamily, fontface,
        adj = c(0.5, 0.5), pos = NULL, offset = 0.5, ..., identifier, name.type)  
## Default S3 method:
lrect(xleft, ybottom, xright, ytop,
        x = (xleft + xright) / 2,
        y = (ybottom + ytop) / 2,
        width = xright - xleft,
        height = ytop - ybottom,
        col = "transparent",
        border = "black",
        lty = 1, lwd = 1, alpha = 1,
        just = "center",
        hjust = NULL, vjust = NULL,
        font, fontface,
        ..., identifier, name.type)
## Default S3 method:
lsegments(x0, y0, x1, y1, x2, y2,
        col, alpha, lty, lwd,
        font, fontface, ..., identifier, name.type)

panel.arrows(...)
panel.lines(...)
panel.points(...)
panel.polygon(...)
panel.rect(...)
panel.segments(...)
panel.text(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code> x, y, x0, y0, x1, y1, x2, y2, xy</code></td>
<td>
<p> locations. <code>x2</code> and
<code>y2</code> are available for for S compatibility.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length, unit</code></td>
<td>

<p>determines extent of arrow head.  <code>length</code> specifies the length
in terms of <code>unit</code>, which can be any valid grid unit as long as
it doesn't need a <code>data</code> argument.  <code>unit</code> defaults to
inches, which is the only option in the base version of the
function, <code>arrows</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angle, code, type, labels, srt, adj, pos, offset</code></td>
<td>
<p> arguments
controlling behaviour.  See respective base functions for details.
For <code>larrows</code> and <code>panel.larrows</code>, <code>type</code> is either
<code>"open"</code> or <code>"closed"</code>, indicating the type of
arrowhead. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ends</code></td>
<td>
<p> serves the same function as <code>code</code>, using
descriptive names rather than integer codes.  If specified, this
overrides <code>code</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col, alpha, lty, lwd, fill, pch, cex, lineheight, font,
fontfamily, fontface, col.line, col.symbol, border</code></td>
<td>
<p> graphical
parameters.  <code>fill</code> applies to points when <code>pch</code> is in
<code>21:25</code> and specifies the fill color, similar to the <code>bg</code>
argument in the base graphics function <code>points</code>. For
devices that support alpha-transparency, a numeric argument
<code>alpha</code> between 0 and 1 can controls transparency.  Be careful
with this, since for devices that do not support alpha-transparency,
nothing will be drawn at all if this is set to anything other than
0.
</p>
<p><code>fill</code>, <code>font</code> and <code>fontface</code> are included in
<code>lrect</code>, <code>larrows</code>, <code>lpolygon</code>, and <code>lsegments</code>
only to ensure that they are not passed down (as <code>gpar</code>
does not like them).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin</code></td>
<td>
<p> for <code>type="h"</code> or <code>type="H"</code>, the value to
which lines drop down. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xleft, ybottom, xright, ytop</code></td>
<td>
<p> see <code>rect</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width, height, just, hjust, vjust</code></td>
<td>
<p> finer control over
rectangles, see <code>grid.rect</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> extra arguments, passed on to lower level functions as
appropriate.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p> character string specifying how <code>NA</code> values are
interpreted for polygons and paths. This is mainly intended for
paths (via <code>grid.path</code>), but can also be specified for
polygons for convenience.
</p>
<p>For polygons, the default rule is <code>"none"</code>, which treats
<code>NA</code>-separated segments as separate polygons. This value is
only valid for polygons. For the other rules (<code>"winding"</code> or
<code>"evenodd"</code>) these segments are interpreted as subpaths,
possibly representing holes, of a single path, and are rendered
using <code>grid.path</code>. Support and rendering speed may
depend on the device being used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>identifier</code></td>
<td>

<p>A character string that is prepended to the name of the grob
that is created.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name.type</code></td>
<td>

<p>A character value indicating whether the name of the grob
should have panel or strip information added to it.
Typically either <code>"panel"</code>, <code>"strip"</code>,
<code>"strip.left"</code>, or <code>""</code> (for no extra information).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are meant to be grid replacements of the corresponding
base R graphics functions, to allow existing Trellis code to be used
with minimal modification.  The functions <code>panel.*</code> are
essentally identical to the <code>l*</code> versions, are recommended for
use in new code (as opposed to ported code) as they have more readable
names.
</p>
<p>See the documentation of the base functions for usage. Not all
arguments are always supported. All these correspond to the default
methods only.


</p>


<h3>Note</h3>

<p>There is a new <code>type="H"</code> option wherever appropriate, which is
similar to <code>type="h"</code>, but with horizontal lines.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code>points</code>, <code>lines</code>, <code>rect</code>,
<code>text</code>, <code>segments</code>, <code>arrows</code>,
<code>Lattice</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
SD &lt;- 0.1
t &lt;- seq(0, 2*pi, length.out = 50) + rnorm(50, sd = SD)
d &lt;- list(x = c(cos(t), NA, rev(0.5 * cos(t))) + rnorm(101, sd = SD),
          y = c(sin(t), NA, rev(0.5 * sin(t))) + rnorm(101, sd = SD))


## rectangles
xyplot(y ~ x, d, panel = panel.rect, col = 4, alpha = 0.5, width = 0.1, height = 0.1)

## points and lines
xyplot(y ~ x, d, panel = panel.lines, col = 4, alpha = 0.5,
       type = "o", pch = 16)

## polygons and paths (with holes)
xyplot(y ~ x, d, panel = panel.polygon, col = 4, alpha = 0.5, rule = "evenodd")

## Example adapted from https://journal.r-project.org/articles/RJ-2012-017/
x &lt;- c(.1, .5, .9, NA, .4, .5, .6, NA, .4, .6, .5)
y &lt;- c(.1, .8, .1, NA, .5, .4, .5, NA, .3, .3, .2)
d &lt;- data.frame(x = x, y = y)
xyplot(y ~ x, data = d, panel = panel.polygon,  rule = "none", col = "grey")
xyplot(y ~ x, data = d, panel = panel.polypath, rule = "winding", col = "grey")
xyplot(y ~ x, data = d, panel = panel.polypath, rule = "evenodd", col = "grey")

</code></pre>


</div>